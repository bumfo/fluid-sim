/*
 * WebGL simulation for Conway's Game of Life
 */
window.LifeSim = function(canvasId, options) {
  options = options || {};

  var dpi = window.devicePixelRatio || 1;

  var SW = document.documentElement.clientWidth || window.innerWidth;
  var SH = document.documentElement.clientHeight || window.innerHeight;

  options.initVFn = options.initVFn || [
    '0.0',
    '0.0'
  ];

  var xRatio = 0.95; // 0.99999;// 0.2 + (0.95 - 0.2) * 0.5 * (1. + Math.cbrt(Math.random() * 2. - 1.)); //  0.2 + Math.random() * (0.95 - 0.2);

  options.initCFn = options.initCFn || [
    'step('+xRatio+', random(vec2(x, y)))',
    'step('+xRatio+', random(vec2(x, y)))',
    'step('+xRatio+', random(vec2(x, y)))',
  ];

  if (options.threshold === undefined) {
    options.threshold = false;
  }

  var WIDTH = options.size || SW;
  var HEIGHT = options.size || SH;

  var underW = WIDTH * dpi;
  var underH = HEIGHT * dpi;


  var canvas = document.getElementById(canvasId);
  document.body.style.width = (underW / dpi) + 'px';
  document.body.style.height = (underH / dpi) + 'px';
  canvas.style.margin = "0 0";
  canvas.style.display = "block";
  canvas.style.transformOrigin = '0 0';
  canvas.style.transform = 'scale('+(1./dpi)+','+(1./dpi)+')';

  var myScale = 1;

  // var speed = 1;
  var speed = 15 / 60;

  var gl = GL.create(canvas, {antialias: false});
  gl.canvas.width = underW;
  gl.canvas.height = underH;
  gl.viewport(0, -gl.canvas.height * (myScale - 1), gl.canvas.width * myScale, gl.canvas.height * myScale);

  // Standard 2-triangle mesh covering the viewport
  // when draw with gl.TRIANGLE_STRIP
  var standardMesh = gl.Mesh.load({
    vertices: [
      [-1, 1],
      [1, 1],
      [-1, -1],
      [1, -1]
    ],
    coords: [
      [0, 1],
      [1, 1],
      [0, 0],
      [1, 0]
    ]
  });

  var standardVertexShaderSrc = '\
    varying vec2 textureCoord;\
    void main() {\
      textureCoord = gl_TexCoord.xy;\
      gl_Position = gl_Vertex;\
    }';

  var randSrc = `
    float PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   
    float PI  = 3.14159265358979323846264 * 00000.1; // PI
    float SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two

    float gold_noise(vec2 coordinate, float seed){
      return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);
    }

    float random(vec2 p) {
      return gold_noise(p, `+(22613+15749.*Math.random())+`);
    }

  `;

  // Given glsl expressions for r, g, b, a mapping (x, y) -> a value, return
  // a function that will paint a color generated by that function evaluated at
  // every pixel of the output buffer. (x, y) will be in the range
  // ([-1, 1], [-1, 1]).
  var makeFunctionPainter = function(r, g, b, a) {
    r = r || '0.0';
    g = g || '0.0';
    b = b || '0.0';
    a = a || '1.0';

    var shader = new gl.Shader(standardVertexShaderSrc, randSrc + `
      varying vec2 textureCoord;
      void main() {
        float x = 2.0 * textureCoord.x - 1.0;
        float y = 2.0 * textureCoord.y - 1.0;
        gl_FragColor = vec4(` + [r, g, b, a].join(',') +`);
      }
    `);

    return function() {
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  };

  // Draw a texture directly to the framebuffer.
  // Will stretch to fit, but in practice the texture and the framebuffer should be
  // the same size.
  var drawTexture = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, '\
      varying vec2 textureCoord; \
      uniform sampler2D inputTexture; \
      void main() { \
        gl_FragColor = texture2D(inputTexture, textureCoord); \
      } \
    ');
    
    return function(inputTexture) {
      inputTexture.bind(0);
      shader.uniforms({
        input: 0
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP)
    };
  })();

  // Draw a texture to the framebuffer, thresholding at 0.5
  var drawTextureThreshold = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, '\
      varying vec2 textureCoord; \
      uniform sampler2D inputTexture; \
      void main() { \
        gl_FragColor = step(0.5, texture2D(inputTexture, textureCoord)); \
      } \
    ');

    return function(inputTexture) {
      inputTexture.bind(0);
      shader.uniforms({
        input: 0
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP)
    };  
  })();

  var gameOfLife = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, `
      uniform sampler2D inputTexture;
      varying vec2 textureCoord;

      void main() {
        vec4 c1 = texture2D(inputTexture, (textureCoord - vec2(-1. / `+SW+`., -1. / `+SH+`.)));
        vec4 c2 = texture2D(inputTexture, (textureCoord - vec2(-1. / `+SW+`., 0)));
        vec4 c3 = texture2D(inputTexture, (textureCoord - vec2(-1. / `+SW+`., +1. / `+SH+`.)));
        vec4 c4 = texture2D(inputTexture, (textureCoord - vec2(0, -1. / `+SH+`.)));
        vec4 c5 = texture2D(inputTexture, (textureCoord - vec2(0, 0)));
        vec4 c6 = texture2D(inputTexture, (textureCoord - vec2(0, +1. / `+SH+`.)));
        vec4 c7 = texture2D(inputTexture, (textureCoord - vec2(+1. / `+SW+`., -1. / `+SH+`.)));
        vec4 c8 = texture2D(inputTexture, (textureCoord - vec2(+1. / `+SW+`., 0)));
        vec4 c9 = texture2D(inputTexture, (textureCoord - vec2(+1. / `+SW+`., +1. / `+SH+`.)));

        vec4 sum = c1 + c2 + c3 + c4 + c6 + c7 + c8 + c9;

        gl_FragColor = step(0.5, c5 * clamp(step(1.9, sum) - step(3.1, sum), 0.0, 1.0) + (1. - c5) * 
          clamp(step(2.9, sum) - step(3.1, sum), 0.0, 1.0));
      }
    `);

    return function(inputTexture) {
      inputTexture.bind(0);

      shader.uniforms({
        input: 0,
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  })();

  // Apply a "splat" of change to a given place with a given
  // blob radius. The effect of the splat has an exponential falloff.
  var addSplat = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, `
      uniform vec4 change;
      uniform vec2 center;
      uniform float radius;
      uniform sampler2D inputTex;
     
      varying vec2 textureCoord;
     
      void main() {
        float dx = (center.x - textureCoord.x) * `+SW+`.;
        float dy = (center.y - textureCoord.y) * `+SH+`.;
        vec4 cur = texture2D(inputTex, textureCoord);
        gl_FragColor = cur + change * exp(-(dx * dx + dy * dy) / radius);
      }
    `);

    return function(inputTexture, change, center, radius) {
      inputTexture.bind(0);
      shader.uniforms({
        change: change,
        center: center,
        radius: radius,
        inputTex: 0
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  })();

  var addPixel = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, `
      uniform vec4 change;
      uniform vec2 center;
      uniform sampler2D inputTex;
     
      varying vec2 textureCoord;
     
      void main() {
        float dx = floor(center.x * `+SW+`.) - floor(textureCoord.x * `+SW+`.);
        float dy = floor(center.y * `+SH+`.) - floor(textureCoord.y * `+SH+`.);
        vec4 cur = texture2D(inputTex, textureCoord);
        gl_FragColor = cur + change * (1. - step(.49, abs(dx))) * (1. - step(.49, abs(dy)));
      }
    `);

    return function(inputTexture, change, center) {
      inputTexture.bind(0);
      shader.uniforms({
        change: change,
        center: center,
        inputTex: 0
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  })();


  // Apply a "splat" of change to a given place with a given
  // blob radius. The effect of the splat has an exponential falloff.
  var addNoisySplat = (function() {
    var shader = new gl.Shader(standardVertexShaderSrc, randSrc + `
      uniform vec4 change;
      uniform vec2 center;
      uniform float radius;
      uniform sampler2D inputTex;

      varying vec2 textureCoord;

      void main() {
        float r = random(textureCoord.xy * 2. - 1.);

        float dx = (center.x - textureCoord.x) * `+SW+`.;
        float dy = (center.y - textureCoord.y) * `+SH+`.;
        vec4 cur = texture2D(inputTex, textureCoord);
        gl_FragColor = step(0.5, cur + change * r * exp(-(dx * dx + dy * dy) / radius));
      }
    `);

    return function(inputTexture, change, center, radius) {
      inputTexture.bind(0);
      shader.uniforms({
        change: change,
        center: center,
        radius: radius,
        inputTex: 0
      });
      shader.draw(standardMesh, gl.TRIANGLE_STRIP);
    };
  })();

  var makeTextures = function(names) {
    var ret = {};
    names.forEach(function(name) {
      ret[name] = new gl.Texture(WIDTH, HEIGHT, {type: gl.UNSIGNED_BYTE, magFilter: gl.NEAREST});
    });

    ret.swap = function(a, b) {
      var temp = ret[a];
      ret[a] = ret[b];
      ret[b] = temp;
    };

    return ret;
  };

  var textures = makeTextures([
    'color0',
    'color1',
    'phantom0',
    'phantom1',
  ]);
  var initCFnPainter = makeFunctionPainter(options.initCFn[0],
                                           options.initCFn[1],
                                           options.initCFn[2]);
  var initPhantomFnPainter = makeFunctionPainter('0.0',
                                                 '0.0',
                                                 '0.0',
                                                 '0.0');
  var clearPainter = makeFunctionPainter('0.0',
                                         '0.0',
                                         '0.0');


  var reset = function() {
    textures.color0.drawTo(initCFnPainter);
    textures.phantom0.drawTo(initPhantomFnPainter);
  };

  reset();

  // Reset the simulation on double click
  // canvas.addEventListener('dblclick', reset);

  gl.ondraw = function() {
    gl.clearColor(1.0, 1.0, 1.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    if (options.threshold) {
      drawTextureThreshold(textures.color0);
    } else {
      drawTexture(textures.color0);
    }

    if (paused) {
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      drawTexture(textures.phantom0);
      gl.disable(gl.BLEND);
    }
  };

  var dragging = null;
  var paused = false;

  function myUpdate() {
    if (!paused && dragging) {
      var ev = dragging;
      var lv = vel;
      var d = Math.hypot(ev.offsetX - lx, ev.offsetY - ly);
      vel = 0.9 * vel + 0.1 * d;
      gb = 0.5 * (1. + Math.sign(gb - 0.5));

      var qq = Math.min(20, Math.floor(Math.sqrt(d)));

      for (var i = 1; i < qq; ++i) {
        textures.color1.drawTo(function() {
          addNoisySplat(
            textures.color0,
            [gb, 1. - gb, 1. - gb, 0.0],
            [(lx + i / qq  * (ev.offsetX - lx)) / underW, 1.0 - (ly + i / qq *  (ev.offsetY - ly)) / underH],
            100 * (lv + i / qq * (vel - lv))
          );
        });
        textures.swap('color0', 'color1');
      }

      textures.color1.drawTo(function() {
        addNoisySplat(
          textures.color0,
          [gb, 1. - gb, 1. - gb, 0.0],
          [ev.offsetX / underW, 1.0 - ev.offsetY / underH],
          100 * vel
        );
      });
      textures.swap('color0', 'color1');

      lx = ev.offsetX;
      ly = ev.offsetY;
    }

    textures.color1.drawTo(function() {
      gameOfLife(textures.color0);
    });
    textures.swap('color0', 'color1');
  };

  var count = 0;

  gl.onupdate = function() {
    if (paused) return;

    if (speed >= 1) {
      for (var i = 1; i < speed; ++i) {
        myUpdate();
      }
      myUpdate();
    } else {
      if (count % ((1 / speed) | 0) === 0) {
        myUpdate();
      }
    }

    ++count;
  }

  gl.ontouchmove = function(ev) {
    textures.color1.drawTo(function() {
      addNoisySplat(
        textures.color0,
        [1, 0, 0, 0.0],
        [ev.offsetX / underW, 1.0 - ev.offsetY / underH],
        4000
      );
    });
    textures.swap('color0', 'color1');
  }

  var gb = 1.;
  var vel = 1.;

  var lx = 0.;
  var ly = 0.;

  function pencil(ev) {
    if ((ev.buttons & 1) !== 0) {
      textures.color1.drawTo(function() {
        addPixel(
          textures.color0,
          [1, 0, 0, 0],
          [ev.offsetX / underW, 1.0 - ev.offsetY / underH]
        );
      });
      textures.swap('color0', 'color1');
    } else if ((ev.buttons & 2) !== 0) {
      textures.color1.drawTo(function() {
        addPixel(
          textures.color0,
          [-1, 0, 0, 0],
          [ev.offsetX / underW, 1.0 - ev.offsetY / underH]
        );
      });
      textures.swap('color0', 'color1');
    }
  }

  gl.onmousedown = function(ev) {
    lx = ev.offsetX;
    ly = ev.offsetY;
    vel = 1;
    gb = 0.5 * (1. + Math.sign(Math.random() - 0.5) * Math.random());

    if (paused) {
      pencil(ev);
    }
  };

  gl.onmousemove = function(ev) {
    if (ev.dragging) {
      if ((ev.buttons & 1) !== 0) {
        dragging = ev;

        // if (paused) {
        //   textures.color1.drawTo(function() {
        //     addPixel(
        //       textures.color0,
        //       [1, 0, 0, 0],
        //       [ev.offsetX / underW, 1.0 - ev.offsetY / underH]
        //     );
        //   });
        //   textures.swap('color0', 'color1');
        // }
      }

      if (paused) {
        pencil(ev);
      }
    }

    if (paused) {
      textures.phantom1.drawTo(initPhantomFnPainter);
      textures.swap('phantom0', 'phantom1');

      textures.phantom1.drawTo(function() {
        addPixel(
          textures.phantom0,
          [0, 1, 0, 1],
          [ev.offsetX / underW, 1.0 - ev.offsetY / underH]
        );
      });
      textures.swap('phantom0', 'phantom1');
    }
  };

  function clear() {
    textures.color0.drawTo(clearPainter);
  }

  var L0 = Math.min(HEIGHT - 2, 1000);

  function fillI(l, b, c, d) {
    for (var i = 0; i < l; ++i) {
      textures.color1.drawTo(function() {
        addPixel(
          textures.color0,
          [d, 0, 0, 0],
          [Math.floor(b * WIDTH + 0.5) / WIDTH, 1.0 - ((Math.floor((HEIGHT - l) / 2) + i + 0.5) / HEIGHT + c - 0.5)]
        );
      });
      textures.swap('color0', 'color1');
    }
  }

  function fill_(l, b, c, d) {
    for (var i = 0; i < l; ++i) {
      textures.color1.drawTo(function() {
        addPixel(
          textures.color0,
          [d, 0, 0, 0],
          [(Math.floor((WIDTH - l) / 2) + i + 1.5) / WIDTH + b - 0.5, 1.0 - Math.floor(c * HEIGHT + 0.5) / HEIGHT]
        );
      });
      textures.swap('color0', 'color1');
    }
  }

  document.addEventListener('keydown', function(ev) {
    if (ev.keyCode === 32) {
      if (paused) {
        myUpdate();
      } else {
        textures.phantom1.drawTo(initPhantomFnPainter);
        textures.swap('phantom0', 'phantom1');
      }
      paused = true;
    } else if (ev.keyCode === 8) {
      ev.preventDefault();
      clear();
    } else if (ev.keyCode === 9 || ev.keyCode === 13) {
      paused = !paused;

      if (paused) {
        textures.phantom1.drawTo(initPhantomFnPainter);
        textures.swap('phantom0', 'phantom1');
      }
    } else if (ev.keyCode === 73) {
      fillI(L0, 0.5, 0.5, 1);
    } else if (ev.key === 'f') {
      speed *= 2;
      if (speed > 16) speed = 16;
      // alert(ev.key);
    } else if (ev.key === 's') {
      speed /= 2;
      if (speed < 1 / 4) speed = 1 / 4;
    } else if (ev.key === 'd') {
      speed = 1;
    }
  });

  gl.onmouseup = function(ev) {
    dragging = null;
  }

  gl.canvas.addEventListener('contextmenu', function(ev) {
    ev.preventDefault();
  });

  // paused = true;
  clear();

  var J0 = 55;
  var J1 = 55;

  var adj = 1;

  function getParameterByName(name) {
    var match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
  }

  var number = getParameterByName('n');
  if (number) {
    J0 = number;
    J1 = number;
    adj = 1;
  }

  var sss = getParameterByName('s');
  if (sss) {
    speed = sss;
  }

  for (var j = J0 ; j <= J1; j += 2) {
    fillI(j, 0.5, ((j - J0 + 1) / (J1 - J0 + 2) - 0.5) / adj + 0.5, 1);
    fill_(j, 0.5, ((j - J0 + 1) / (J1 - J0 + 2) - 0.5) / adj + 0.5, 1);

    fillI(3, 0.5, ((j - J0 + 1) / (J1 - J0 + 2) - 0.5) / adj + 0.5, -1);
    fill_(3, 0.5, ((j - J0 + 1) / (J1 - J0 + 2) - 0.5) / adj + 0.5, -1);
  }

  gl.animate();
};
